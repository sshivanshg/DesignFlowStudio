Installing
Install as package#
You can install @supabase/supabase-js via the terminal.


npm

Yarn

pnpm
npm install @supabase/supabase-js
Install via CDN#
You can install @supabase/supabase-js via CDN links.

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
//or
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
Use at runtime in Deno#
You can use supabase-js in the Deno runtime via JSR:

import { createClient } from 'jsr:@supabase/supabase-js@2'
Initializing
Create a new client for use in the browser.

You can initialize a new Supabase client using the createClient() method.

The Supabase client is your entrypoint to the rest of the Supabase functionality and is the easiest way to interact with everything we offer within the Supabase ecosystem.

Parameters
supabaseUrl
Required
string
The unique Supabase URL which is supplied when you create a new project in your project dashboard.

supabaseKey
Required
string
The unique Supabase Key which is supplied when you create a new project in your project dashboard.

options
Optional
SupabaseClientOptions
Details
Creating a client
With a custom domain
With additional parameters
With custom schemas
Custom fetch implementation
React Native options with AsyncStorage
React Native options with Expo SecureStore
import { createClient } from '@supabase/supabase-js'
// Create a single supabase client for interacting with your database
const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')
TypeScript support
supabase-js has TypeScript support for type inference, autocompletion, type-safe queries, and more.

With TypeScript, supabase-js detects things like not null constraints and generated columns. Nullable columns are typed as T | null when you select the column. Generated columns will show a type error when you insert to it.

supabase-js also detects relationships between tables. A referenced table with one-to-many relationship is typed as T[]. Likewise, a referenced table with many-to-one relationship is typed as T | null.

Generating TypeScript Types#
You can use the Supabase CLI to generate the types. You can also generate the types from the dashboard.

supabase gen types typescript --project-id abcdefghijklmnopqrst > database.types.ts
These types are generated from your database schema. Given a table public.movies, the generated types will look like:

create table public.movies (
  id bigint generated always as identity primary key,
  name text not null,
  data jsonb null
);
export type Json = string | number | boolean | null | { [key: string]: Json | undefined } | Json[]
export interface Database {
  public: {
    Tables: {
      movies: {
        Row: {               // the data expected from .select()
          id: number
          name: string
          data: Json | null
        }
        Insert: {            // the data to be passed to .insert()
          id?: never         // generated columns must not be supplied
          name: string       // `not null` columns with no default must be supplied
          data?: Json | null // nullable columns can be omitted
        }
        Update: {            // the data to be passed to .update()
          id?: never
          name?: string      // `not null` columns are optional on .update()
          data?: Json | null
        }
      }
    }
  }
}
Using TypeScript type definitions#
You can supply the type definitions to supabase-js like so:

import { createClient } from '@supabase/supabase-js'
import { Database } from './database.types'
const supabase = createClient<Database>(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_ANON_KEY
)
Helper types for Tables and Joins#
You can use the following helper types to make the generated TypeScript types easier to use.

Sometimes the generated types are not what you expect. For example, a view's column may show up as nullable when you expect it to be not null. Using type-fest, you can override the types like so:

export type Json = // ...
export interface Database {
  // ...
}
import { MergeDeep } from 'type-fest'
import { Database as DatabaseGenerated } from './database-generated.types'
export { Json } from './database-generated.types'
// Override the type for a specific column in a view:
export type Database = MergeDeep<
  DatabaseGenerated,
  {
    public: {
      Views: {
        movies_view: {
          Row: {
            // id is a primary key in public.movies, so it must be `not null`
            id: number
          }
        }
      }
    }
  }
>
You can also override the type of an individual successful response if needed:

// Partial type override allows you to only override some of the properties in your results
const { data } = await supabase.from('countries').select().overrideTypes<Array<{ id: string }>>()
// For a full replacement of the original return type use the `{ merge: false }` property as second argument
const { data } = await supabase
  .from('countries')
  .select()
  .overrideTypes<Array<{ id: string }>, { merge: false }>()
// Use it with `maybeSingle` or `single`
const { data } = await supabase.from('countries').select().single().overrideTypes<{ id: string }>()
The generated types provide shorthands for accessing tables and enums.

import { Database, Tables, Enums } from "./database.types.ts";
// Before üòï
let movie: Database['public']['Tables']['movies']['Row'] = // ...
// After üòç
let movie: Tables<'movies'>
Response types for complex queries#
supabase-js always returns a data object (for success), and an error object (for unsuccessful requests).

These helper types provide the result types from any query, including nested types for database joins.

Given the following schema with a relation between cities and countries, we can get the nested CountriesWithCities type:

create table countries (
  "id" serial primary key,
  "name" text
);
create table cities (
  "id" serial primary key,
  "name" text,
  "country_id" int references "countries"
);
import { QueryResult, QueryData, QueryError } from '@supabase/supabase-js'
const countriesWithCitiesQuery = supabase
  .from("countries")
  .select(`
    id,
    name,
    cities (
      id,
      name
    )
  `);
type CountriesWithCities = QueryData<typeof countriesWithCitiesQuery>;
const { data, error } = await countriesWithCitiesQuery;
if (error) throw error;
const countriesWithCities: CountriesWithCities = data;
Fetch data
Perform a SELECT query on the table or view.

By default, Supabase projects return a maximum of 1,000 rows. This setting can be changed in your project's API settings. It's recommended that you keep it low to limit the payload size of accidental or malicious requests. You can use range() queries to paginate through your data.
select() can be combined with Filters
select() can be combined with Modifiers
apikey is a reserved keyword if you're using the Supabase Platform and should be avoided as a column name.
Parameters
columns
Optional
Query
The columns to retrieve, separated by commas. Columns can be renamed when returned with customName:columnName

options
Required
object
Named parameters

Details
Getting your data
Selecting specific columns
Query referenced tables
Query referenced tables with spaces in their names
Query referenced tables through a join table
Query the same referenced table multiple times
Query nested foreign tables through a join table
Filtering through referenced tables
Querying referenced table with count
Querying with count option
Querying JSON data
Querying referenced table with inner join
Switching schemas per query
const { data, error } = await supabase
  .from('characters')
  .select()
Data source
Response
Insert data
Perform an INSERT into the table or view.

Parameters
values
Required
One of the following options
The values to insert. Pass an object to insert a single row or an array to insert multiple rows.

Details
Option 1
Row
Option 2
Array<Row>
options
Optional
object
Named parameters

Details
Create a record
Create a record and return it
Bulk create
const { error } = await supabase
  .from('countries')
  .insert({ id: 1, name: 'Mordor' })
Data source
Response
Update data
Perform an UPDATE on the table or view.

update() should always be combined with Filters to target the item(s) you wish to update.
Parameters
values
Required
Row
The values to update with

options
Required
object
Named parameters

Details
Updating your data
Update a record and return it
Updating JSON data
const { error } = await supabase
  .from('instruments')
  .update({ name: 'piano' })
  .eq('id', 1)
Data source
Response
Upsert data
Perform an UPSERT on the table or view. Depending on the column(s) passed to onConflict, .upsert() allows you to perform the equivalent of .insert() if a row with the corresponding onConflict columns doesn't exist, or if it does exist, perform an alternative action depending on ignoreDuplicates.

Primary keys must be included in values to use upsert.
Parameters
values
Required
One of the following options
The values to upsert with. Pass an object to upsert a single row or an array to upsert multiple rows.

Details
Option 1
Row
Option 2
Array<Row>
options
Optional
object
Named parameters

Details
Upsert your data
Bulk Upsert your data
Upserting into tables with constraints
const { data, error } = await supabase
  .from('instruments')
  .upsert({ id: 1, name: 'piano' })
  .select()
Data source
Response
Delete data
Perform a DELETE on the table or view.

delete() should always be combined with filters to target the item(s) you wish to delete.
If you use delete() with filters and you have RLS enabled, only rows visible through SELECT policies are deleted. Note that by default no rows are visible, so you need at least one SELECT/ALL policy that makes the rows visible.
When using delete().in(), specify an array of values to target multiple rows with a single query. This is particularly useful for batch deleting entries that share common criteria, such as deleting users by their IDs. Ensure that the array you provide accurately represents all records you intend to delete to avoid unintended data removal.
Parameters
options
Required
object
Named parameters

Details
Delete a single record
Delete a record and return it
Delete multiple records
const response = await supabase
  .from('countries')
  .delete()
  .eq('id', 1)
Data source
Response
Call a Postgres function
Perform a function call.

You can call Postgres functions as Remote Procedure Calls, logic in your database that you can execute from anywhere. Functions are useful when the logic rarely changes‚Äîlike for password resets and updates.

create or replace function hello_world() returns text as $$
  select 'Hello world';
$$ language sql;
To call Postgres functions on Read Replicas, use the get: true option.

Parameters
fn
Required
FnName
The function name to call

args
Required
Fn['Args']
The arguments to pass to the function call

options
Required
object
Named parameters

Details
Call a Postgres function without arguments
Call a Postgres function with arguments
Bulk processing
Call a Postgres function with filters
Call a read-only Postgres function
const { data, error } = await supabase.rpc('hello_world')
Data source
Response
Using filters
Filters allow you to only return rows that match certain conditions.

Filters can be used on select(), update(), upsert(), and delete() queries.

If a Postgres function returns a table response, you can also apply filters.

Applying Filters
Chaining
Conditional Chaining
Filter by values within a JSON column
Filter referenced tables
const { data, error } = await supabase
  .from('instruments')
  .select('name, section_id')
  .eq('name', 'violin')    // Correct
const { data, error } = await supabase
  .from('instruments')
  .eq('name', 'violin')    // Incorrect
  .select('name, section_id')
Notes
Column is equal to a value
Match only rows where column is equal to value.

Parameters
column
Required
ColumnName
The column to filter on

value
Required
The value to filter with

With `select()`
const { data, error } = await supabase
  .from('characters')
  .select()
  .eq('name', 'Leia')
Data source
Response
Column is not equal to a value
Match only rows where column is not equal to value.

Parameters
column
Required
ColumnName
The column to filter on

value
Required
The value to filter with

With `select()`
const { data, error } = await supabase
  .from('characters')
  .select()
  .neq('name', 'Leia')
Data source
Response
Column is greater than a value
Match only rows where column is greater than value.

Parameters
column
Required
One of the following options
The column to filter on

Details
Option 1
ColumnName
Option 2
string
value
Required
One of the following options
The value to filter with

Details
Option 1
Row['ColumnName']
Option 2
unknown
With `select()`
const { data, error } = await supabase
  .from('characters')
  .select()
  .gt('id', 2)
Data source
Response
Notes
Column is greater than or equal to a value
Match only rows where column is greater than or equal to value.

Parameters
column
Required
One of the following options
The column to filter on

Details
Option 1
ColumnName
Option 2
string
value
Required
One of the following options
The value to filter with

Details
Option 1
Row['ColumnName']
Option 2
unknown
With `select()`
const { data, error } = await supabase
  .from('characters')
  .select()
  .gte('id', 2)
Data source
Response
Column is less than a value
Match only rows where column is less than value.

Parameters
column
Required
One of the following options
The column to filter on

Details
Option 1
ColumnName
Option 2
string
value
Required
One of the following options
The value to filter with

Details
Option 1
Row['ColumnName']
Option 2
unknown
With `select()`
const { data, error } = await supabase
  .from('characters')
  .select()
  .lt('id', 2)
Data source
Response
Column is less than or equal to a value
Match only rows where column is less than or equal to value.

Parameters
column
Required
One of the following options
The column to filter on

Details
Option 1
ColumnName
Option 2
string
value
Required
One of the following options
The value to filter with

Details
Option 1
Row['ColumnName']
Option 2
unknown
With `select()`
const { data, error } = await supabase
  .from('characters')
  .select()
  .lte('id', 2)
Data source
Response
Column matches a pattern
Match only rows where column matches pattern case-sensitively.

Parameters
column
Required
One of the following options
The column to filter on

Details
Option 1
ColumnName
Option 2
string
pattern
Required
string
The pattern to match with

With `select()`
const { data, error } = await supabase
  .from('characters')
  .select()
  .like('name', '%Lu%')
Data source
Response
Column matches a case-insensitive pattern
Match only rows where column matches pattern case-insensitively.

Parameters
column
Required
One of the following options
The column to filter on

Details
Option 1
ColumnName
Option 2
string
pattern
Required
string
The pattern to match with

With `select()`
const { data, error } = await supabase
  .from('characters')
  .select()
  .ilike('name', '%lu%')
Data source
Response
Column is a value
Match only rows where column IS value.

Parameters
column
Required
One of the following options
The column to filter on

Details
Option 1
ColumnName
Option 2
string
value
Required
One of the following options
The value to filter with

Details
Option 1
null
Option 2
boolean
Checking for nullness, true or false
const { data, error } = await supabase
  .from('countries')
  .select()
  .is('name', null)
Data source
Response
Notes
Column is in an array
Match only rows where column is included in the values array.

Parameters
column
Required
ColumnName
The column to filter on

values
Required
Array
The values array to filter with

With `select()`
const { data, error } = await supabase
  .from('characters')
  .select()
  .in('name', ['Leia', 'Han'])
Data source
Response
Column contains every element in a value
Only relevant for jsonb, array, and range columns. Match only rows where column contains every element appearing in value.

Parameters
column
Required
One of the following options
The jsonb, array, or range column to filter on

Details
Option 1
ColumnName
Option 2
string
value
Required
One of the following options
The jsonb, array, or range value to filter with

Details
Option 1
string
Option 2
Record<string, unknown>
Option 3
Array<Row['ColumnName']>
Option 4
Array<unknown>
On array columns
On range columns
On `jsonb` columns
const { data, error } = await supabase
  .from('issues')
  .select()
  .contains('tags', ['is:open', 'priority:low'])
Data source
Response
Contained by value
Only relevant for jsonb, array, and range columns. Match only rows where every element appearing in column is contained by value.

Parameters
column
Required
One of the following options
The jsonb, array, or range column to filter on

Details
Option 1
ColumnName
Option 2
string
value
Required
One of the following options
The jsonb, array, or range value to filter with

Details
Option 1
string
Option 2
Record<string, unknown>
Option 3
Array<Row['ColumnName']>
Option 4
Array<unknown>
On array columns
On range columns
On `jsonb` columns
const { data, error } = await supabase
  .from('classes')
  .select('name')
  .containedBy('days', ['monday', 'tuesday', 'wednesday', 'friday'])
Data source
Response
Greater than a range
Only relevant for range columns. Match only rows where every element in column is greater than any element in range.

Parameters
column
Required
One of the following options
The range column to filter on

Details
Option 1
ColumnName
Option 2
string
range
Required
string
The range to filter with

With `select()`
const { data, error } = await supabase
  .from('reservations')
  .select()
  .rangeGt('during', '[2000-01-02 08:00, 2000-01-02 09:00)')
Data source
Response
Notes
Greater than or equal to a range
Only relevant for range columns. Match only rows where every element in column is either contained in range or greater than any element in range.

Parameters
column
Required
One of the following options
The range column to filter on

Details
Option 1
ColumnName
Option 2
string
range
Required
string
The range to filter with

With `select()`
const { data, error } = await supabase
  .from('reservations')
  .select()
  .rangeGte('during', '[2000-01-02 08:30, 2000-01-02 09:30)')
Data source
Response
Notes
Less than a range
Only relevant for range columns. Match only rows where every element in column is less than any element in range.

Parameters
column
Required
One of the following options
The range column to filter on

Details
Option 1
ColumnName
Option 2
string
range
Required
string
The range to filter with

With `select()`
const { data, error } = await supabase
  .from('reservations')
  .select()
  .rangeLt('during', '[2000-01-01 15:00, 2000-01-01 16:00)')
Data source
Response
Notes
Less than or equal to a range
Only relevant for range columns. Match only rows where every element in column is either contained in range or less than any element in range.

Parameters
column
Required
One of the following options
The range column to filter on

Details
Option 1
ColumnName
Option 2
string
range
Required
string
The range to filter with

With `select()`
const { data, error } = await supabase
  .from('reservations')
  .select()
  .rangeLte('during', '[2000-01-01 14:00, 2000-01-01 16:00)')
Data source
Response
Notes
Mutually exclusive to a range
Only relevant for range columns. Match only rows where column is mutually exclusive to range and there can be no element between the two ranges.

Parameters
column
Required
One of the following options
The range column to filter on

Details
Option 1
ColumnName
Option 2
string
range
Required
string
The range to filter with

With `select()`
const { data, error } = await supabase
  .from('reservations')
  .select()
  .rangeAdjacent('during', '[2000-01-01 12:00, 2000-01-01 13:00)')
Data source
Response
Notes
With a common element
Only relevant for array and range columns. Match only rows where column and value have an element in common.

Parameters
column
Required
One of the following options
The array or range column to filter on

Details
Option 1
ColumnName
Option 2
string
value
Required
One of the following options
The array or range value to filter with

Details
Option 1
string
Option 2
Array<Row['ColumnName']>
Option 3
Array<unknown>
On array columns
On range columns
const { data, error } = await supabase
  .from('issues')
  .select('title')
  .overlaps('tags', ['is:closed', 'severity:high'])
Data source
Response
Match a string
Only relevant for text and tsvector columns. Match only rows where column matches the query string in query.

For more information, see Postgres full text search.
Parameters
column
Required
One of the following options
The text or tsvector column to filter on

Details
Option 1
ColumnName
Option 2
string
query
Required
string
The query text to match with

options
Optional
object
Named parameters

Details
Text search
Basic normalization
Full normalization
Websearch
const result = await supabase
  .from("texts")
  .select("content")
  .textSearch("content", `'eggs' & 'ham'`, {
    config: "english",
  });
Data source
Response
Match an associated value
Match only rows where each column in query keys is equal to its associated value. Shorthand for multiple .eq()s.

Parameters
query
Required
One of the following options
The object to filter with, with column names as keys mapped to their filter values

Details
Option 1
Record<ColumnName, Row['ColumnName']>
Option 2
Record<string, unknown>
With `select()`
const { data, error } = await supabase
  .from('characters')
  .select('name')
  .match({ id: 2, name: 'Leia' })
Data source
Response
Don't match the filter
Match only rows which doesn't satisfy the filter.

not() expects you to use the raw PostgREST syntax for the filter values.

.not('id', 'in', '(5,6,7)')  // Use `()` for `in` filter
.not('arraycol', 'cs', '{"a","b"}')  // Use `cs` for `contains()`, `{}` for array values
Parameters
column
Required
One of the following options
The column to filter on

Details
Option 1
ColumnName
Option 2
string
operator
Required
One of the following options
The operator to be negated to filter with, following PostgREST syntax

Details
Option 1
FilterOperator
Option 2
string
value
Required
One of the following options
The value to filter with, following PostgREST syntax

Details
Option 1
Row['ColumnName']
Option 2
unknown
With `select()`
const { data, error } = await supabase
  .from('countries')
  .select()
  .not('name', 'is', null)
Data source
Response
Match at least one filter
Match only rows which satisfy at least one of the filters.

or() expects you to use the raw PostgREST syntax for the filter names and values.

.or('id.in.(5,6,7), arraycol.cs.{"a","b"}')  // Use `()` for `in` filter, `{}` for array values and `cs` for `contains()`.
.or('id.in.(5,6,7), arraycol.cd.{"a","b"}')  // Use `cd` for `containedBy()`
Parameters
filters
Required
string
The filters to use, following PostgREST syntax

options
Required
object
Named parameters

Details
With `select()`
Use `or` with `and`
Use `or` on referenced tables
const { data, error } = await supabase
  .from('characters')
  .select('name')
  .or('id.eq.2,name.eq.Han')
Data source
Response
Match the filter
Match only rows which satisfy the filter. This is an escape hatch - you should use the specific filter methods wherever possible.

filter() expects you to use the raw PostgREST syntax for the filter values.

.filter('id', 'in', '(5,6,7)')  // Use `()` for `in` filter
.filter('arraycol', 'cs', '{"a","b"}')  // Use `cs` for `contains()`, `{}` for array values
Parameters
column
Required
One of the following options
The column to filter on

Details
Option 1
ColumnName
Option 2
string
operator
Required
One of the following options
The operator to filter with, following PostgREST syntax

Details
Option 1
FilterOperator
Option 2
"not.eq"
Option 3
"not.neq"
Option 4
"not.gt"
Option 5
"not.gte"
Option 6
"not.lt"
Option 7
"not.lte"
Option 8
"not.like"
Option 9
"not.ilike"
Option 10
"not.is"
Option 11
"not.in"
Option 12
"not.cs"
Option 13
"not.cd"
Option 14
"not.sl"
Option 15
"not.sr"
Option 16
"not.nxl"
Option 17
"not.nxr"
Option 18
"not.adj"
Option 19
"not.ov"
Option 20
"not.fts"
Option 21
"not.plfts"
Option 22
"not.phfts"
Option 23
"not.wfts"
Option 24
string
value
Required
unknown
The value to filter with, following PostgREST syntax

With `select()`
On a referenced table
const { data, error } = await supabase
  .from('characters')
  .select()
  .filter('name', 'in', '("Han","Yoda")')
Data source
Response
Using modifiers
Filters work on the row level‚Äîthey allow you to return rows that only match certain conditions without changing the shape of the rows. Modifiers are everything that don't fit that definition‚Äîallowing you to change the format of the response (e.g., returning a CSV string).

Modifiers must be specified after filters. Some modifiers only apply for queries that return rows (e.g., select() or rpc() on a function that returns a table response).

Return data after inserting
Perform a SELECT on the query result.

Parameters
columns
Optional
Query
The columns to retrieve, separated by commas

With `upsert()`
const { data, error } = await supabase
  .from('characters')
  .upsert({ id: 1, name: 'Han Solo' })
  .select()
Data source
Response
Order the results
Order the query result by column.

Parameters
column
Required
One of the following options
The column to order by

Details
Option 1
ColumnName
Option 2
string
options
Optional
object
Named parameters

Details
With `select()`
On a referenced table
Order parent table by a referenced table
const { data, error } = await supabase
  .from('characters')
  .select('id, name')
  .order('id', { ascending: false })
Data source
Response
Limit the number of rows returned
Limit the query result by count.

Parameters
count
Required
number
The maximum number of rows to return

options
Required
object
Named parameters

Details
With `select()`
On a referenced table
const { data, error } = await supabase
  .from('characters')
  .select('name')
  .limit(1)
Data source
Response
Limit the query to a range
Limit the query result by starting at an offset from and ending at the offset to. Only records within this range are returned. This respects the query order and if there is no order clause the range could behave unexpectedly. The from and to values are 0-based and inclusive: range(1, 3) will include the second, third and fourth rows of the query.

Parameters
from
Required
number
The starting index from which to limit the result

to
Required
number
The last index to which to limit the result

options
Required
object
Named parameters

Details
With `select()`
const { data, error } = await supabase
  .from('countries')
  .select('name')
  .range(0, 1)
Data source
Response
Set an abort signal
Set the AbortSignal for the fetch request.

You can use this to set a timeout for the request.

Parameters
signal
Required
AbortSignal
The AbortSignal to use for the fetch request

Aborting requests in-flight
Set a timeout
const ac = new AbortController()
ac.abort()
const { data, error } = await supabase
  .from('very_big_table')
  .select()
  .abortSignal(ac.signal)
Response
Notes
Retrieve one row of data
Return data as a single object instead of an array of objects.

With `select()`
const { data, error } = await supabase
  .from('characters')
  .select('name')
  .limit(1)
  .single()
Data source
Response
Retrieve zero or one row of data
Return data as a single object instead of an array of objects.

Return Type
One of the following options
Details
Option 1
null
Option 2
ResultOne
With `select()`
const { data, error } = await supabase
  .from('characters')
  .select()
  .eq('name', 'Katniss')
  .maybeSingle()
Data source
Response
Retrieve as a CSV
Return data as a string in CSV format.

Return Type
string
Return data as CSV
const { data, error } = await supabase
  .from('characters')
  .select()
  .csv()
Data source
Response
Notes
Override type of successful response
Override the type of the returned data.

Deprecated: use overrideTypes method instead
Override type of successful response
Override type of object response
const { data } = await supabase
  .from('countries')
  .select()
  .returns<Array<MyType>>()
Response
Partially override or replace type of successful response
Override the type of the returned data field in the response.

Complete Override type of successful response
Complete Override type of object response
Partial Override type of successful response
Partial Override type of object response
const { data } = await supabase
  .from('countries')
  .select()
  .overrideTypes<Array<MyType>, { merge: false }>()
Response
Using explain
Return data as the EXPLAIN plan for the query.

For debugging slow queries, you can get the Postgres EXPLAIN execution plan of a query using the explain() method. This works on any query, even for rpc() or writes.

Explain is not enabled by default as it can reveal sensitive information about your database. It's best to only enable this for testing environments but if you wish to enable it for production you can provide additional protection by using a pre-request function.

Follow the Performance Debugging Guide to enable the functionality on your project.

Parameters
options
Required
object
Named parameters

Details
Return Type
One of the following options
Details
Option 1
string
Option 2
Array<Record<string, unknown>>
Get the execution plan
Get the execution plan with analyze and verbose
const { data, error } = await supabase
  .from('characters')
  .select()
  .explain()
Data source
Response
Notes
Overview
The auth methods can be accessed via the supabase.auth namespace.

By default, the supabase client sets persistSession to true and attempts to store the session in local storage. When using the supabase client in an environment that doesn't support local storage, you might notice the following warning message being logged:

No storage option exists to persist the session, which may result in unexpected behavior when using auth. If you want to set persistSession to true, please provide a storage option or you may set persistSession to false to disable this warning.

This warning message can be safely ignored if you're not using auth on the server-side. If you are using auth and you want to set persistSession to true, you will need to provide a custom storage implementation that follows this interface.

Any email links and one-time passwords (OTPs) sent have a default expiry of 24 hours. We have the following rate limits in place to guard against brute force attacks.

The expiry of an access token can be set in the "JWT expiry limit" field in your project's auth settings. A refresh token never expires and can only be used once.

Create auth client
Create auth client (server-side)
import { createClient } from '@supabase/supabase-js'
const supabase = createClient(supabase_url, anon_key)
Create a new user
Creates a new user.

By default, the user needs to verify their email address before logging in. To turn this off, disable Confirm email in your project.
Confirm email determines if users need to confirm their email address after signing up.
If Confirm email is enabled, a user is returned but session is null.
If Confirm email is disabled, both a user and a session are returned.
When the user confirms their email address, they are redirected to the SITE_URL by default. You can modify your SITE_URL or add additional redirect URLs in your project.
If signUp() is called for an existing confirmed user:
When both Confirm email and Confirm phone (even when phone provider is disabled) are enabled in your project, an obfuscated/fake user object is returned.
When either Confirm email or Confirm phone (even when phone provider is disabled) is disabled, the error message, User already registered is returned.
To fetch the currently logged-in user, refer to getUser().
Parameters
credentials
Required
One of the following options
Details
Option 1
object
Details
Option 2
object
Details
Return Type
Promise<One of the following options>
Details
Option 1
object
Details
Option 2
object
Details
Sign up with an email and password
Sign up with a phone number and password (SMS)
Sign up with a phone number and password (whatsapp)
Sign up with additional user metadata
Sign up with a redirect URL
const { data, error } = await supabase.auth.signUp({
  email: 'example@email.com',
  password: 'example-password',
})
Response
Listen to auth events
Receive a notification every time an auth event happens.

Subscribes to important events occurring on the user's session.
Use on the frontend/client. It is less useful on the server.
Events are emitted across tabs to keep your application's UI up-to-date. Some events can fire very frequently, based on the number of tabs open. Use a quick and efficient callback function, and defer or debounce as many operations as you can to be performed outside of the callback.
Important: A callback can be an async function and it runs synchronously during the processing of the changes causing the event. You can easily create a dead-lock by using await on a call to another method of the Supabase library.
Avoid using async functions as callbacks.
Limit the number of await calls in async callbacks.
Do not use other Supabase functions in the callback function. If you must, dispatch the functions once the callback has finished executing. Use this as a quick way to achieve this:
supabase.auth.onAuthStateChange((event, session) => {
  setTimeout(async () => {
    // await on other Supabase function here
    // this runs right after the callback has finished
  }, 0)
})
Emitted events:
INITIAL_SESSION
Emitted right after the Supabase client is constructed and the initial session from storage is loaded.
SIGNED_IN
Emitted each time a user session is confirmed or re-established, including on user sign in and when refocusing a tab.
Avoid making assumptions as to when this event is fired, this may occur even when the user is already signed in. Instead, check the user object attached to the event to see if a new user has signed in and update your application's UI.
This event can fire very frequently depending on the number of tabs open in your application.
SIGNED_OUT
Emitted when the user signs out. This can be after:
A call to supabase.auth.signOut().
After the user's session has expired for any reason:
User has signed out on another device.
The session has reached its timebox limit or inactivity timeout.
User has signed in on another device with single session per user enabled.
Check the User Sessions docs for more information.
Use this to clean up any local storage your application has associated with the user.
TOKEN_REFRESHED
Emitted each time a new access and refresh token are fetched for the signed in user.
It's best practice and highly recommended to extract the access token (JWT) and store it in memory for further use in your application.
Avoid frequent calls to supabase.auth.getSession() for the same purpose.
There is a background process that keeps track of when the session should be refreshed so you will always receive valid tokens by listening to this event.
The frequency of this event is related to the JWT expiry limit configured on your project.
USER_UPDATED
Emitted each time the supabase.auth.updateUser() method finishes successfully. Listen to it to update your application's UI based on new profile information.
PASSWORD_RECOVERY
Emitted instead of the SIGNED_IN event when the user lands on a page that includes a password recovery link in the URL.
Use it to show a UI to the user where they can reset their password.
Parameters
callback
Required
function
A callback function to be invoked when an auth event happens.

Details
Return Type
object
Details
Listen to auth changes
Listen to sign out
Store OAuth provider tokens on sign in
Use React Context for the User's session
Listen to password recovery events
Listen to sign in
Listen to token refresh
Listen to user updates
const { data } = supabase.auth.onAuthStateChange((event, session) => {
  console.log(event, session)
  if (event === 'INITIAL_SESSION') {
    // handle initial session
  } else if (event === 'SIGNED_IN') {
    // handle sign in event
  } else if (event === 'SIGNED_OUT') {
    // handle sign out event
  } else if (event === 'PASSWORD_RECOVERY') {
    // handle password recovery event
  } else if (event === 'TOKEN_REFRESHED') {
    // handle token refreshed event
  } else if (event === 'USER_UPDATED') {
    // handle user updated event
  }
})
// call unsubscribe to remove the callback
data.subscription.unsubscribe()
Create an anonymous user
Creates a new anonymous user.

Returns an anonymous user
It is recommended to set up captcha for anonymous sign-ins to prevent abuse. You can pass in the captcha token in the options param.
Parameters
credentials
Optional
SignInAnonymouslyCredentials
Details
Return Type
Promise<One of the following options>
Details
Option 1
object
Details
Option 2
object
Details
Create an anonymous user
Create an anonymous user with custom user metadata
const { data, error } = await supabase.auth.signInAnonymously({
  options: {
    captchaToken
  }
});
Response
Sign in a user
Log in an existing user with an email and password or phone and password.

Requires either an email and password or a phone number and password.
Parameters
credentials
Required
One of the following options
Details
Option 1
object
Details
Option 2
object
Details
Return Type
Promise<One of the following options>
Details
Option 1
object
Details
Option 2
object
Details
Sign in with email and password
Sign in with phone and password
const { data, error } = await supabase.auth.signInWithPassword({
  email: 'example@email.com',
  password: 'example-password',
})
Response
